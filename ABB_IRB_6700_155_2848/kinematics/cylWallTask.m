%% cylWallTask.m
%
% Description:
%   Simulate the kinematics (forward, inverse) required to print a
%   cylindrical wall in the workspace in Tech AG53 with the ABB IRB 6700
%   arm.
%
% Notes:
%   1 - all linear dimensions are in meters except where otherwise noted.
%   2 - requires kinematics library from Modern Robotics by Lynch & Park:
%       https://github.com/NxRLab/ModernRobotics/tree/master/packages/MATLAB
%
% Author:
%   Dan Lynch
%
% Date:
%   March 9, 2019

%% main function
function cylWallTask
    clear;
    close all;
    clc;
    
    % add Modern Robotics library to path:
    addpath('/home/daniel/ModernRobotics/packages/MATLAB/mr');
    
    % declare presistent structs:
    persistent perim slab robot workpiece
    
    [perim,slab,robot,workpiece] = init_workspace(perim,slab,robot,workpiece);
    robot = init_robot(robot);
    visualize_workspace(perim,slab,robot,workpiece);
    
end

%% Initialize the robot
function [robot] = init_robot(robot)
% Warning: cannot be called before init_workspace() is called.
%
% Takes the initialized "robot" struct generated by init_workspace() and
% adds fields for link dimensions and the pose of every joint frame.

robot.nJoints = 6;

% dimensions (meters)
A = 0.2;
B = 0.532;
C = 0.633;
D = 2.276;
E = 1.125;
F = 1.873;
G = 1.3925;

% dimensions of prismatic end-effector:
H = 1.35;
I = 1.65;

base_x = 0.377;
base_y = 0;
base_z = 0.780;

elbow_offset = 0.2;

% calculate screw axes for each joint, starting with the rotation triplet
% (omega):
omega = [0,0,1;
         0,1,0;
         0,1,0;
         1,0,0;
         0,1,0;
         1,0,0];

% points used to calculate the linear triplet of each screw axis 6-vector:
q = [0,0,0;
     base_x,base_y,base_z;
     base_x,base_y,base_z + E;
     base_x,base_y,base_z + E + elbow_offset;
     base_x + G,base_y,base_z + E + elbow_offset;
     base_x,base_y,base_z + E + elbow_offset];
 
% use the points "q" and triplets "omega" to find the linear triple of each
% screw axis:
for i = 1:robot.nJoints
    v(i,:) = cross(-omega(i,:),q(i,:));
end

% finally, the screw axes in space frame:
Slist = [omega, v];

% M{i} is the SE(3) pose of the ith joint in the robot's home position

M{1} = [1,0,0,0; 0,1,0,0; 0,0,1,0; 0,0,0,1];
M{2} = [0,1,0,base_x; 0,0,1,base_y; 1,0,0,base_z; 0,0,0,1];
M{3} = [0,1,0,base_x; 0,0,1,base_y; 1,0,0,base_z + E; 0,0,0,1];
M{4} = [0,0,1,base_x; 0,1,0,base_y; -1,0,0,base_z + E + elbow_offset; ...
    0,0,0,1];
M{5} = [1,0,0,base_x + G; 0,0,1,base_y; 0,-1,0,base_z + E + elbow_offset; 0,0,0,1];
M{6} = [0, 0, 1, base_x + G + A;
      0, 1, 0, base_y;
     -1,0, 0, base_z + E + elbow_offset;
      0, 0, 0, 1];
  
joints_home = [0;0;0;0;0;0];
joints_max = deg2rad([170;85;70;300;130;360]);
joints_min = deg2rad([-170;-65;-180;-300;-130;-360]);
joints_max_ext = deg2rad([0;60;-30;0;0;0]);
joints_min_ext = deg2rad([0;0;-30;0;0;0]);
thetalist = joints_max_ext;

% Calculate FK of each joint given thetalist
for i = 1:robot.nJoints
   T{i} = FKinSpace(M{i}, Slist(1:i,:)', thetalist(1:i));
end

% express robot frames in task space (rotate by 90 degrees about z-axis):
T_robot2task = [cos(pi/2), -sin(pi/2), 0, 0;
                sin(pi/2),  cos(pi/2), 0, 0;
                0,          0,         1, 0;
                0,          0,         0, 1];
for i = 1:robot.nJoints
   T{i} = T_robot2task*T{i};
end

for i = 1:robot.nJoints
    robot.frames.joint{i}.x = robot.frames.base.x + T{i}(1,4);
    robot.frames.joint{i}.y = robot.frames.base.y + T{i}(2,4);
    robot.frames.joint{i}.z = robot.frames.base.z + T{i}(3,4);
end

end

%% Workspace description in task-space frame
function [perim,slab,robot,workpiece] = init_workspace(perim,slab,robot,workpiece)
% The workspace contains 4 things (represented as structs):
%   1 - workspace "perimeter"
%   2 - concrete "slab" (underneath the robot base)
%   3 - "robot" (whose base is coincident with the center of the concrete
%   slab)
%   4 - "workpiece" (the thing the robot will 3D print)

% perimeter dimensions
perim.frame.x = 0; % x-coordinate of the perimeter frame in the task-space frame
perim.frame.y = 0; % y-coordinate of the perimeter frame in the task-space frame
perim.width_dim = 4.7244;   % extends in the task-frame x-direction
perim.length_dim = 4.4196;  % extends in the task-frame y-direction
perim.height_dim = 4;       % extends in the task-frame z-direction (this vlaue is a guess)

% perimeter corners (A-D, clockwise, A is coincident with task-space frame)
perim.Ax = perim.frame.x + 0;
perim.Ay = perim.frame.y + 0;

perim.Bx = perim.frame.x + 0;
perim.By = perim.frame.y + perim.length_dim;

perim.Cx = perim.frame.x + perim.width_dim;
perim.Cy = perim.frame.y + perim.length_dim;

perim.Dx = perim.frame.x + perim.width_dim;
perim.Dy = perim.frame.y + 0;

perim.x_coords = [perim.Ax, perim.Bx, perim.Cx, perim.Dx];
perim.y_coords = [perim.Ay, perim.By, perim.Cy, perim.Dy];

% slab dimensions:
slab.offset.x = 2.3622;
slab.offset.y = 1.016;
slab.width_dim = 1.1176;    % extends in task-frame x-direction
slab.length_dim = 1.1176;   % extends in task-frame y-direction
slab.frame.x = slab.offset.x - 0.5*slab.width_dim; % x-coordinate of the slab frame in the task-space frame
slab.frame.y = slab.offset.y - 0.5*slab.length_dim; % y-coordinate of the slab frame in the task-space frame

% slab corners (A-D, clockwise, A is coincident with task-space frame)
slab.Ax = slab.frame.x + 0;
slab.Ay = slab.frame.y + 0;

slab.Bx = slab.frame.x + 0;
slab.By = slab.frame.y + slab.length_dim;

slab.Cx = slab.frame.x + slab.width_dim;
slab.Cy = slab.frame.y + slab.length_dim;

slab.Dx = slab.frame.x + slab.width_dim;
slab.Dy = slab.frame.y + 0;

slab.x_coords = [slab.Ax, slab.Bx, slab.Cx, slab.Dx];
slab.y_coords = [slab.Ay, slab.By, slab.Cy, slab.Dy];

% robot workspace dimensions (subsequent code will generate the actual
% robot frames and links)
robot.frames.base.x = slab.frame.x + 0.5*slab.width_dim;
robot.frames.base.y = slab.frame.y + 0.5*slab.length_dim;
robot.frames.base.z = 0;

robot.reach.min_reach = 0.994; % minimum reachable distance from robot base frame
robot.reach.max_reach = 2.848; % maximum reachable distance from robot base frame
robot.reach.min_reach_circle.x = robot.frames.base.x + ...
    robot.reach.min_reach*cos(linspace(0,2*pi,101));
robot.reach.min_reach_circle.y = robot.frames.base.y + ...
    robot.reach.min_reach*sin(linspace(0,2*pi,101));
robot.reach.max_reach_circle.x = robot.frames.base.x + ...
    robot.reach.max_reach*cos(linspace(0,2*pi,101));
robot.reach.max_reach_circle.y = robot.frames.base.y + ...
    robot.reach.max_reach*sin(linspace(0,2*pi,101));

% workpiece (3D printed cylindrical wall) dimensions
workpiece.offset.x = 0;
workpiece.offset.y = 1;
workpiece.radii.outer_radius = 1.1;
workpiece.frame.x = robot.frames.base.x + workpiece.radii.outer_radius + workpiece.offset.x;
workpiece.frame.y = robot.frames.base.y + workpiece.radii.outer_radius + workpiece.offset.y;
workpiece.points.x = workpiece.frame.x + workpiece.radii.outer_radius*sin(linspace(0,2*pi,101));
workpiece.points.y = workpiece.frame.y + workpiece.radii.outer_radius*cos(linspace(0,2*pi,101));

end

%% Visualize workspace
function visualize_workspace(perim,slab,robot,workpiece)
figure;
% plot workspace perimeter:
plot3(horzcat(perim.x_coords,perim.Ax),horzcat(perim.y_coords,perim.Ay),...
    zeros(1,length(perim.x_coords)+1),'k-');
hold on;

% plot slab:
plot3(horzcat(slab.x_coords,slab.Ax),horzcat(slab.y_coords,slab.Ay),...
    zeros(1,length(slab.x_coords)+1),'k-.');

% plot robot base, max & min reach:
plot3(robot.frames.base.x,robot.frames.base.y,0,'k.','MarkerSize',20);
plot3(robot.reach.min_reach_circle.x,robot.reach.min_reach_circle.y,...
    zeros(1,length(robot.reach.min_reach_circle.x)),'k:')
plot3(robot.reach.max_reach_circle.x,robot.reach.max_reach_circle.y,...
    zeros(1,length(robot.reach.max_reach_circle.x)),'k--')

% plot workpiece:
plot3(workpiece.frame.x,workpiece.frame.y,0,'b.','MarkerSize',20)
plot3(workpiece.points.x,workpiece.points.y,...
    zeros(1,length(workpiece.points.x)),'b-')

% plot robot:
cc = lines(6);
joint_marker_size = 50;
link_line_width = 10;
plot3(robot.frames.joint{1}.x,robot.frames.joint{1}.y,robot.frames.joint{1}.z,...
    '.','Color',cc(1,:),'MarkerSize',joint_marker_size);
hold on;
for i = 2:6
   plot3(robot.frames.joint{i}.x,robot.frames.joint{i}.y,...
    robot.frames.joint{i}.z,'.','Color',cc(i,:),...
       'MarkerSize',joint_marker_size);
   line([robot.frames.joint{i-1}.x,robot.frames.joint{i}.x],...
       [robot.frames.joint{i-1}.y,robot.frames.joint{i}.y],...
       [robot.frames.joint{i-1}.z,robot.frames.joint{i}.z],...
       'Color',cc(i,:),'LineWidth',link_line_width);
end

axis([-1, perim.width_dim + 1, -1, perim.length_dim + 1, 0, perim.height_dim]);
pbaspect([perim.width_dim, perim.width_dim, perim.height_dim]/perim.width_dim)

legend('workspace boundary','slab','robot: base','robot: min reach',...
    'robot: max reach','workpiece: center','workpiece: outer wall','Location','Best');
view(60,30); % initialize viewing angle (azimuth, elevation)
xlabel('x [m]')
ylabel('y [m]')
zlabel('z [m]')
end